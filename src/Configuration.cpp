/* Generated by re2c 0.13.5 on Fri Feb 10 02:10:46 2017 */
#line 1 "Configuration.r2c"
/* Generated by re2c 0.13.6 on Thu Jul 10 21:25:20 2014 */
#line 1 "Configuration.r2c"
#include <ostream>

#include "babb/utils/memory.h"
#include "memwrappers.h"

#include <boost/algorithm/string.hpp>
#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>

#include "bcplus/Configuration.h"
#include "Configuration.h"

namespace u = babb::utils;
namespace fs = boost::filesystem;

namespace cplusode {
namespace cplusode_bin {

const u::ref_ptr<const ReferencedString> Configuration::s_ts_zero				= new ReferencedString("0");
const u::ref_ptr<const ReferencedString> Configuration::s_ts_static_incr		= new ReferencedString("ST");
const u::ref_ptr<const ReferencedString> Configuration::s_ts_static_static		= new ReferencedString("ST");
const u::ref_ptr<const ReferencedString> Configuration::s_ts_dynamic_incr		= s_ts_static_incr;
const u::ref_ptr<const ReferencedString> Configuration::s_ts_dynamic_static		= new ReferencedString("AT");
const u::ref_ptr<const ReferencedString> Configuration::s_ts_action_incr		= new ReferencedString("ST-1");
const u::ref_ptr<const ReferencedString> Configuration::s_ts_action_static		= new ReferencedString("AT-1");
const u::ref_ptr<const ReferencedString> Configuration::s_ts_maxstep_incr		= s_ts_static_incr;
const u::ref_ptr<const ReferencedString> Configuration::s_ts_maxstep_static		= new ReferencedString("maxstep");


Configuration::Configuration(char const* bin, char const* version)
	: bcplus::Configuration(bin, version), _ostream(&std::cout), _input_lang(Input::CPLUS), _output_lang(Output::INCREMENTAL), _enforceDomain(true), _enforceAdditiveDomain(true) {
	/* Intentionally left blank */
}

Configuration::~Configuration() {
	clearOutputFile();
}

void Configuration::clearOutputFile() {
	if (_output_file && _ostream && _ostream != &std::cout) {
		((fs::ofstream*)_ostream)->close();
		delete _ostream;
	}
	_output_file = NULL;
	_ostream = &std::cout;

}


bool Configuration::outputFile(ReferencedPath const* file) {
	if (!file) {
		clearOutputFile();
		return true;
	}


	fs::ofstream* new_out = new fs::ofstream(*file);
	if (new_out->good()) {
		clearOutputFile();
		_output_file = file;
		_ostream = new_out;
		return true;

	} else {
		delete new_out;
		return false;
	}
}

bool Configuration::outputStream(std::ostream& out) {
	clearOutputFile();
	_ostream = &out;
	return true;
}

bool Configuration::good() {
	return true;
}

std::ostream& Configuration::outputOptions(std::ostream& out) const {
	out << "     Translator Options:"																<< std::endl
		<< "          -l=<LANGUAGE>"																<< std::endl
		<< "          --language=<LANGUAGE>"														<< std::endl
		<< "               - Sets the language that should be accepted to <LANGUAGE>:"				<< std::endl
		<< "                    <LANGUAGE>: C+, BC, BC+, MVPF [default: C+]"						<< std::endl
		<< "          -m=<MODE>"																	<< std::endl
		<< "          --mode=<MODE>"																<< std::endl
		<< "               - Sets the compilation mode to <MODE>:"									<< std::endl
		<< "                    <MODE>:"															<< std::endl
		<< "                         STATIC - Targets standard ASP solvers such as Clingo"			<< std::endl
		<< "                         INCREMENTAL - Targets incremental ASP solvers such as iClingo"	<< std::endl
		<< "          -o=<FILE>"																	<< std::endl
		<< "          --output-file=<FILE>"															<< std::endl
		<< "                - Outputs the translated program to <FILE>."							<< std::endl
		<< "          -d"																			<< std::endl
		<< "          --no-domain"																	<< std::endl
		<< "                - Suppresses domain-enforcing rules for non-additive constants in the " << std::endl
		<< "                  translated file."														<< std::endl
		<< "          -a"																			<< std::endl
		<< "          --no-additive-domain"															<< std::endl
		<< "                - Suppresses domain-enforcing rules for additive constants in the "		<< std::endl
		<< "                  translated file." 													<< std::endl
		<< std::endl;
	return bcplus::Configuration::outputOptions(out);
}

#define EXTRACT_NAME val.assign(token, (size_t)(opt - token - 1));
#define EXTRACT_NAME_VAL										\
	{															\
		size_t n;												\
		if (*(opt-1) == '=') { val2 = opt; n = 2; }				\
		else if (opt2) { val2 = opt2; n = 1; }					\
		else return Status::STAT_NEXT_ARG;						\
		val.assign(token, (size_t)(opt - token - n));			\
	}


int Configuration::parseOption(char const* opt, char const* opt2) {
	std::string val, val2;
	char const* token = opt;
	char const* marker;
	int option = 0;

	
#line 130 "<stdout>"
	{
		char yych;

		yych = *opt;
		switch (yych) {
		case '\n':	goto yy2;
		case '-':	goto yy3;
		default:	goto yy5;
		}
yy2:
		opt = marker;
		goto yy4;
yy3:
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy8;
		case 'a':	goto yy11;
		case 'c':	goto yy6;
		case 'd':	goto yy13;
		case 'l':	goto yy17;
		case 'm':	goto yy15;
		case 'o':	goto yy9;
		default:	goto yy4;
		}
yy4:
#line 158 "Configuration.r2c"
		{
										goto re2c_other; }
#line 159 "<stdout>"
yy5:
		yych = *++opt;
		goto yy4;
yy6:
		++opt;
#line 154 "Configuration.r2c"
		{
												  EXTRACT_NAME;
												  option = Option::IGNORE;
												  goto re2c_finish; }
#line 170 "<stdout>"
yy8:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy22;
		case 'm':	goto yy23;
		case 'n':	goto yy24;
		case 'o':	goto yy25;
		default:	goto yy2;
		}
yy9:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy21;
		default:	goto yy10;
		}
yy10:
#line 150 "Configuration.r2c"
		{
										EXTRACT_NAME_VAL;
										option = Option::OUTPUT_FILE;
										goto re2c_finish; }
#line 192 "<stdout>"
yy11:
		++opt;
#line 146 "Configuration.r2c"
		{
										EXTRACT_NAME;
										option = Option::NO_ADD_DOMAIN_ENFORCE;
										goto re2c_finish; }
#line 200 "<stdout>"
yy13:
		++opt;
#line 142 "Configuration.r2c"
		{
										EXTRACT_NAME;
										option = Option::NO_DOMAIN_ENFORCE;
										goto re2c_finish; }
#line 208 "<stdout>"
yy15:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy20;
		default:	goto yy16;
		}
yy16:
#line 138 "Configuration.r2c"
		{
										EXTRACT_NAME_VAL;
										option = Option::OUTPUT_MODE;
										goto re2c_finish; }
#line 221 "<stdout>"
yy17:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy19;
		default:	goto yy18;
		}
yy18:
#line 133 "Configuration.r2c"
		{
										EXTRACT_NAME_VAL;
										option = Option::INPUT_MODE;
										goto re2c_finish; }
#line 234 "<stdout>"
yy19:
		yych = *++opt;
		goto yy18;
yy20:
		yych = *++opt;
		goto yy16;
yy21:
		yych = *++opt;
		goto yy10;
yy22:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy58;
		default:	goto yy2;
		}
yy23:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy56;
		default:	goto yy2;
		}
yy24:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy35;
		default:	goto yy2;
		}
yy25:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy26;
		default:	goto yy2;
		}
yy26:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy27;
		default:	goto yy2;
		}
yy27:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy28;
		default:	goto yy2;
		}
yy28:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy29;
		default:	goto yy2;
		}
yy29:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy30;
		default:	goto yy2;
		}
yy30:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy31;
		default:	goto yy2;
		}
yy31:
		yych = *++opt;
		switch (yych) {
		case 'f':	goto yy32;
		default:	goto yy2;
		}
yy32:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy33;
		default:	goto yy2;
		}
yy33:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy34;
		default:	goto yy2;
		}
yy34:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy9;
		default:	goto yy2;
		}
yy35:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy36;
		default:	goto yy2;
		}
yy36:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy37;
		case 'd':	goto yy38;
		default:	goto yy2;
		}
yy37:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy43;
		default:	goto yy2;
		}
yy38:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy39;
		default:	goto yy2;
		}
yy39:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy40;
		default:	goto yy2;
		}
yy40:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy41;
		default:	goto yy2;
		}
yy41:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy42;
		default:	goto yy2;
		}
yy42:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy13;
		default:	goto yy2;
		}
yy43:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy44;
		default:	goto yy2;
		}
yy44:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy45;
		default:	goto yy2;
		}
yy45:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy46;
		default:	goto yy2;
		}
yy46:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy47;
		default:	goto yy2;
		}
yy47:
		yych = *++opt;
		switch (yych) {
		case 'v':	goto yy48;
		default:	goto yy2;
		}
yy48:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy49;
		default:	goto yy2;
		}
yy49:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy50;
		default:	goto yy2;
		}
yy50:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy51;
		default:	goto yy2;
		}
yy51:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy52;
		default:	goto yy2;
		}
yy52:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy53;
		default:	goto yy2;
		}
yy53:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy54;
		default:	goto yy2;
		}
yy54:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy55;
		default:	goto yy2;
		}
yy55:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy11;
		default:	goto yy2;
		}
yy56:
		yych = *++opt;
		switch (yych) {
		case 'd':	goto yy57;
		default:	goto yy2;
		}
yy57:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy15;
		default:	goto yy2;
		}
yy58:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy59;
		default:	goto yy2;
		}
yy59:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy60;
		default:	goto yy2;
		}
yy60:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy61;
		default:	goto yy2;
		}
yy61:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy62;
		default:	goto yy2;
		}
yy62:
		yych = *++opt;
		switch (yych) {
		case 'g':	goto yy63;
		default:	goto yy2;
		}
yy63:
		++opt;
		switch ((yych = *opt)) {
		case 'e':	goto yy17;
		default:	goto yy2;
		}
	}
#line 160 "Configuration.r2c"


re2c_other:
	// It's an unrecognized argument, try the parser arguments
	int ret;
	if ((ret = bcplus::Configuration::parseOption(token,opt2)) == Status::STAT_BAD_ARG) {
		// not recognized by the parser, assume it's an input file
		if (token[0] != '-' && boost::filesystem::is_regular_file(token)) {
			_input_files.push_back(new ReferencedPath(token));
			return Status::STAT_OK;
		} else if (token[0] != '-') {
			std::cerr << "ERROR: Could not find file \"" << token << "\"." << std::endl;
			return Status::STAT_FILE_NOT_FOUND;
		} return Status::STAT_BAD_ARG;
	} else return ret;

re2c_finish:
	// Recognized the argument... Validate

	switch (option) {
	case Option::IGNORE:
		ret = Status::STAT_OK;
		break;
	case Option::INPUT_MODE:

		if (boost::iequals(val2, "c+") || boost::iequals(val2, "cplus")) {
			_input_lang = Input::CPLUS;
			return Status::STAT_OK;
		} else if (boost::iequals(val2, "bc")) {
			_input_lang = Input::BC;
			return Status::STAT_OK;
		} else if (boost::iequals(val2, "bc+") || boost::iequals(val2, "bcplus")) {
			_input_lang = Input::BCPLUS;
			return Status::STAT_OK;
		} else if (boost::iequals(val2, "mvpf")) {
			_input_lang = Input::MVPF;
			return Status::STAT_OK;
		} else {
			std::cerr << "ERROR: Bad value provided for command line option. Expected \"c+\", \"bc\", \"bc+\", or \"mvpf\" for argument \"" + val + "\"." << std::endl;
			return Status::STAT_BAD_ARG;
		}
	case Option::OUTPUT_MODE:
		if (boost::iequals(val2, "static")) {
			_output_lang = Output::STATIC;
			return Status::STAT_OK;
		} else if (boost::iequals(val2, "incremental")) {
			_output_lang = Output::INCREMENTAL;
			return Status::STAT_OK;
		} else {
			std::cerr << "ERROR: Bad value provided for command line option. Expected \"incremental\" or \"static\" for argument \"" + val + "\"." << std::endl;
			return Status::STAT_BAD_ARG;
		}
	case Option::NO_DOMAIN_ENFORCE:
		_enforceDomain = false;
		return Status::STAT_OK;
	case Option::NO_ADD_DOMAIN_ENFORCE:
		_enforceAdditiveDomain = false;
		return Status::STAT_OK;

	case Option::OUTPUT_FILE:
		if (boost::filesystem::native(val2)) {
			u::ref_ptr<const ReferencedPath> file = new ReferencedPath(val2);
			if (!outputFile(file)) {
				std::cerr << "ERROR: Could not open \"" << val2 << "\" for writing." << std::endl;
				return Status::STAT_FILE_NOT_FOUND;
			} else return Status::STAT_OK;
        } else {
            std::cerr << "ERROR: \"" << val2 << "\" is not a valid file path." << std::endl;
			return Status::STAT_BAD_ARG;
		}
	default:
		// this shouldn't happen
		std::cerr << "ERROR: INTERNAL ERROR: Received unknown option from option parser." << std::endl;
		return Status::STAT_BAD_ARG;
	};

	return Status::STAT_OK;

}


ReferencedString const* Configuration::ts(TS::type ts_class) const {


	switch (_output_lang) {
	case Output::STATIC:
		switch (ts_class) {
		case TS::STATIC:	return s_ts_static_static;
		case TS::DYNAMIC:	return s_ts_dynamic_static;
		case TS::ACTION:	return s_ts_action_static;
		case TS::MAXSTEP:	return s_ts_maxstep_static;
		case TS::ZERO:
		default:			return s_ts_zero;
		};
		break;

	case Output::INCREMENTAL:
	case Output::INCREMENTAL_NO_DECL:
	default:

		switch (ts_class) {
		case TS::STATIC:	return s_ts_static_incr;
		case TS::DYNAMIC:	return s_ts_dynamic_incr;
		case TS::ACTION:	return s_ts_action_incr;
		case TS::MAXSTEP:	return s_ts_maxstep_incr;
		case TS::ZERO:
		default:			return s_ts_zero;
		};

	};

}



}}
