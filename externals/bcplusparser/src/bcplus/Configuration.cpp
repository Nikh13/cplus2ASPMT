/* Generated by re2c 0.13.5 on Fri Feb 10 02:02:10 2017 */
#line 1 "bcplus/Configuration.r2c"

#include <string>
#include <iostream>

#ifndef BOOST_FILESYSTEM_VERSION
#define BOOST_FILESYSTEM_VERSION 3
#endif
#include <boost/filesystem.hpp>
#include <boost/iostreams/stream.hpp>
#include <boost/iostreams/device/null.hpp>

#include "babb/utils/memory.h"
#include "babb/utils/utils.h"

#include "bcplus/Location.h"
#include "bcplus/Configuration.h"

namespace ios = boost::iostreams;
namespace fs = boost::filesystem;

namespace bcplus {

const size_t Configuration::DEFAULT_VERB_LEVEL = Verb::STD;

Configuration::Configuration(char const* bin, char const* version)
{
	_verb = DEFAULT_VERB_LEVEL;
	if (version) _version = new ReferencedString(version);
	if (bin) _bin_name = new ReferencedString(fs::path(bin).filename().native());
	_parse_trace = false;
}


Configuration::~Configuration()
{ /* Intentionally left blank */ }


int Configuration::load(int argc, char const** argv) {
	int ret = Status::STAT_OK;

	// Figure out who we are
	fs::path bin = argv[0];
	_bin_name = new ReferencedString(bin.filename().native());

	// parse arguments

	for (int i = 1; i < argc; i++) {
		ret = parseOption(argv[i], NULL);

		if (ret == Status::STAT_NEXT_ARG) {
			if (i < argc-1 && argv[i+1][0] != '-') {
				ret = parseOption(argv[i], argv[i+1]);
				i++;
			} else {
				std::cerr << "ERROR: Expected an option following \"" << argv[i] << "\"." << std::endl;
				return Status::STAT_BAD_ARG;
			}
		}

		switch (ret) {
		case Status::STAT_BAD_ARG:
			std::cerr << "ERROR: Unrecognized option: \"" << argv[i] << "\"." << std::endl;
			/* no break */
		case Status::STAT_HELP:
		case Status::STAT_VERSION:
			return ret;
		default:
			continue;
		};

	}
	return ret;
}

bool Configuration::good() {
	return true;
}

std::ostream& Configuration::ostream(Verb::type v) const {
	static ios::stream<ios::null_sink> NULLSTREAM( (ios::null_sink()) );

	if (v > _verb) return NULLSTREAM;
	else if (v == Verb::ERROR || v == Verb::WARN) return std::cerr;
#ifdef NDEBUG
	else if (v > Verb::STD) return NULLSTREAM;
#endif
	else return std::cout;
}
void Configuration::error(std::string const& err, Location const* loc) const {
	std::ostream& out = ostream(Verb::ERROR);

	out << "ERROR: ";
	if (loc) out << *loc << ": ";
	out << err << std::endl;
}

#define EXTRACT_NAME val.assign(token, (size_t)(opt - token - 1));
#define EXTRACT_NAME_VAL                                        \
    {                                                           \
        size_t n;                                               \
        if (*(opt-1) == '=') { val2 = opt; n = 2; }             \
        else if (opt2) { val2 = opt2; n = 1; }                  \
        else return Status::STAT_NEXT_ARG;                      \
        val.assign(token, (size_t)(opt - token - n));           \
    }

int Configuration::parseOption(char const* opt, char const* opt2) {
	int ret = Status::STAT_OK;
	std::string val, val2;
    char const* marker;
	char const* token = opt;
	int option, int_v;
	bool good;



    
#line 121 "<stdout>"
	{
		char yych;

		yych = *opt;
		switch (yych) {
		case '\n':	goto yy2;
		case '-':	goto yy3;
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy5;
		default:	goto yy6;
		}
yy2:
		opt = marker;
		goto yy4;
yy3:
		yych = *(marker = ++opt);
		switch (yych) {
		case '-':	goto yy14;
		case '?':
		case 'h':	goto yy17;
		case 'c':	goto yy12;
		case 's':	goto yy19;
		case 'v':	goto yy15;
		default:	goto yy4;
		}
yy4:
#line 160 "bcplus/Configuration.r2c"
		{
												  val = token;
												  option = Option::BAD;
												  goto re2c_finish; }
#line 204 "<stdout>"
yy5:
		yych = *(marker = ++opt);
		switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy7;
		case '=':	goto yy9;
		default:	goto yy4;
		}
yy6:
		yych = *++opt;
		goto yy4;
yy7:
		++opt;
		yych = *opt;
		switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':	goto yy7;
		case '=':	goto yy9;
		default:	goto yy2;
		}
yy9:
		++opt;
		yych = *opt;
		if (yych >= 0x01) goto yy9;
#line 154 "bcplus/Configuration.r2c"
		{
												  char const* c = strchr(token, '=');
												  val.assign(token, (size_t)(c - token));
												  val2.assign(c+1,opt-c-1);
												  option = Option::MACRO_DEF;
												  goto re2c_finish; }
#line 358 "<stdout>"
yy12:
		++opt;
#line 150 "bcplus/Configuration.r2c"
		{
												  EXTRACT_NAME;
												  option = Option::IGNORE;
												  goto re2c_finish; }
#line 366 "<stdout>"
yy14:
		yych = *++opt;
		switch (yych) {
		case 'h':	goto yy25;
		case 'p':	goto yy24;
		case 's':	goto yy22;
		case 'v':	goto yy23;
		default:	goto yy2;
		}
yy15:
		++opt;
#line 146 "bcplus/Configuration.r2c"
		{
												  EXTRACT_NAME;
												  option = Option::VERSION;
												  goto re2c_finish; }
#line 383 "<stdout>"
yy17:
		++opt;
#line 142 "bcplus/Configuration.r2c"
		{
												  EXTRACT_NAME;
												  option =  Option::HELP;
												  goto re2c_finish; }
#line 391 "<stdout>"
yy19:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy21;
		default:	goto yy20;
		}
yy20:
#line 126 "bcplus/Configuration.r2c"
		{
												  EXTRACT_NAME_VAL;
												  option = Option::SYMTAB_INPUT;
												  goto re2c_finish; }
#line 404 "<stdout>"
yy21:
		yych = *++opt;
		goto yy20;
yy22:
		yych = *++opt;
		switch (yych) {
		case 'y':	goto yy47;
		default:	goto yy2;
		}
yy23:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy39;
		default:	goto yy2;
		}
yy24:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy28;
		default:	goto yy2;
		}
yy25:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy26;
		default:	goto yy2;
		}
yy26:
		yych = *++opt;
		switch (yych) {
		case 'l':	goto yy27;
		default:	goto yy2;
		}
yy27:
		yych = *++opt;
		switch (yych) {
		case 'p':	goto yy17;
		default:	goto yy2;
		}
yy28:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy29;
		default:	goto yy2;
		}
yy29:
		yych = *++opt;
		switch (yych) {
		case 's':	goto yy30;
		default:	goto yy2;
		}
yy30:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy31;
		default:	goto yy2;
		}
yy31:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy32;
		default:	goto yy2;
		}
yy32:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy33;
		default:	goto yy2;
		}
yy33:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy34;
		default:	goto yy2;
		}
yy34:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy35;
		default:	goto yy2;
		}
yy35:
		yych = *++opt;
		switch (yych) {
		case 'c':	goto yy36;
		default:	goto yy2;
		}
yy36:
		yych = *++opt;
		switch (yych) {
		case 'e':	goto yy37;
		default:	goto yy2;
		}
yy37:
		++opt;
#line 138 "bcplus/Configuration.r2c"
		{
												  EXTRACT_NAME;
												  option = Option::PARSE_TRACE;
												  goto re2c_finish; }
#line 505 "<stdout>"
yy39:
		yych = *++opt;
		switch (yych) {
		case 'r':	goto yy40;
		default:	goto yy2;
		}
yy40:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy42;
		case 's':	goto yy41;
		default:	goto yy2;
		}
yy41:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy45;
		default:	goto yy2;
		}
yy42:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy44;
		default:	goto yy43;
		}
yy43:
#line 134 "bcplus/Configuration.r2c"
		{
												  EXTRACT_NAME_VAL;
												  option = Option::VERBOSITY;
												  goto re2c_finish; }
#line 537 "<stdout>"
yy44:
		yych = *++opt;
		goto yy43;
yy45:
		yych = *++opt;
		switch (yych) {
		case 'o':	goto yy46;
		default:	goto yy2;
		}
yy46:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy15;
		default:	goto yy2;
		}
yy47:
		yych = *++opt;
		switch (yych) {
		case 'm':	goto yy48;
		default:	goto yy2;
		}
yy48:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy49;
		default:	goto yy2;
		}
yy49:
		yych = *++opt;
		switch (yych) {
		case 'a':	goto yy50;
		default:	goto yy2;
		}
yy50:
		yych = *++opt;
		switch (yych) {
		case 'b':	goto yy51;
		default:	goto yy2;
		}
yy51:
		yych = *++opt;
		switch (yych) {
		case '-':	goto yy52;
		default:	goto yy2;
		}
yy52:
		yych = *++opt;
		switch (yych) {
		case 'i':	goto yy54;
		case 'o':	goto yy53;
		default:	goto yy2;
		}
yy53:
		yych = *++opt;
		switch (yych) {
		case 'u':	goto yy55;
		default:	goto yy2;
		}
yy54:
		yych = *++opt;
		switch (yych) {
		case 'n':	goto yy19;
		default:	goto yy2;
		}
yy55:
		yych = *++opt;
		switch (yych) {
		case 't':	goto yy56;
		default:	goto yy2;
		}
yy56:
		++opt;
		switch ((yych = *opt)) {
		case '=':	goto yy58;
		default:	goto yy57;
		}
yy57:
#line 130 "bcplus/Configuration.r2c"
		{
												  EXTRACT_NAME_VAL;
												  option = Option::SYMTAB_OUTPUT;
												  goto re2c_finish; }
#line 620 "<stdout>"
yy58:
		++opt;
		yych = *opt;
		goto yy57;
	}
#line 164 "bcplus/Configuration.r2c"


re2c_finish:

	switch (option) {
	case Option::SYMTAB_INPUT:
//		if (fs::native(val2)) {
			_symtab_in = new ReferencedPath(val2);
//		} else {
//			ret = Status::STAT_BAD_ARG;
//			std::cerr << "ERROR: \"" << val2 << "\" is not a valid file path." << std::endl;
//		}
		break;
	case Option::SYMTAB_OUTPUT:
//		if (fs::native(val2)) {
			_symtab_out = new ReferencedPath(val2);
//		} else {
//			ret = Status::STAT_BAD_ARG;
//			std::cerr << "ERROR: \"" << val2 << "\" is not a valid file path." << std::endl;
//
//		}
		break;

	case Option::VERBOSITY:
		good = babb::utils::fromString(val2.c_str(), int_v);
		if (!good || int_v < 0) {
			ret = Status::STAT_BAD_ARG;
			std::cerr << "ERROR: Bad value provided for command line option. Expected a non-negative integer for argument \"" << val << "\"." << std::endl;
		} else {
			verbosity(int_v);
		}
		break;
	case Option::PARSE_TRACE:
		_parse_trace = true;
		break;
	case Option::MACRO_DEF:
		addMacro(new ReferencedString(val), new ReferencedString(val2));
		break;

	case Option::HELP:
		ret = Status::STAT_HELP;
		break;
	case Option::IGNORE:
		ret = Status::STAT_OK;
		break;
	case Option::VERSION:
		ret = Status::STAT_VERSION;
		break;
	case Option::BAD:
	default:
		ret = Status::STAT_BAD_ARG;
		break;
	}
	return ret;

}

std::ostream& Configuration::outputVersion(std::ostream& out) const {
	if (binaryName()) out << *binaryName() << " ";
	if (version()) out << "version " << *version() << std::endl;
	return out;
}

std::ostream& Configuration::outputHelp(std::ostream& out) const {
	out << "---------------------------------------------------------------------------------------"<< std::endl;
	outputVersion(out)
		<< "---------------------------------------------------------------------------------------"<< std::endl
		<< "Usage: " ;
		if (binaryName()) out << *binaryName();
		else out << "<binary>";
		out << " [<OPTIONS>] [<CONSTANTS>] <INPUT_FILES>" 											<< std::endl
		<< "---------------------------------------------------------------------------------------"<< std::endl
		<< "OPTIONS:"																				<< std::endl;
	outputOptions(out);
	out 																							<< std::endl
		<< "CONSTANTS:"																				<< std::endl
		<< "     <identifier>=<value>"																<< std::endl
		<< "          - Defines <identifier> to be a macro which expands to <value>"				<< std::endl;
	return out;
}

std::ostream& Configuration::outputOptions(std::ostream& out) const {
	out << "     Parser Options:"																	<< std::endl
		<< "          -s=<FILE>"																	<< std::endl
		<< "          --symtab-in=<FILE>"															<< std::endl
		<< "               - An XML file to read the initial symbol table in from. [none]"			<< std::endl
		<< "          --symtab-out=<FILE>"															<< std::endl
		<< "               - A file to write the final symbol table to. [none]"						<< std::endl
		<< "          --verb=<LEVEL>"																<< std::endl
		<< "               - The level of output to show:"											<< std::endl
		<< "                    " << Verb::ERROR 		<< "  - Error output only"					<< std::endl
		<< "                    " << Verb::WARN 		<< "  - Warnings"							<< std::endl
		<< "                    " << Verb::STD	 		<< "  - Standard messages [default]"		<< std::endl
		<< "                 Only available when compiled in debug mode:"							<< std::endl
		<< "                    " << Verb::OP 			<< "  - Operation level trace output" 		<< std::endl
		<< "                    " << Verb::DETAIL	 	<< "  - Detailed debugging messages"		<< std::endl
		<< "                    " << Verb::TRACE_PARSER	<< "+ - Parser debugging messages"			<< std::endl
		<< "          --parse-trace"																<< std::endl
		<< "               - Enable lemon parser trace output."										<< std::endl
																									<< std::endl
		<< "     Other Options:"																	<< std::endl
		<< "          -v"																			<< std::endl
		<< "          --version"																	<< std::endl
		<< "               - Displays the version dialog."											<< std::endl
		<< "          -h"																			<< std::endl
		<< "          --help"																		<< std::endl
		<< "               - Shows this dialog."													<< std::endl;
	return out;

}

}
